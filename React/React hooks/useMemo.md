#react-hooks  [[React.memo()]] [[React hooks]]

# ==useMemo==
[Documentation](https://ru.reactjs.org/docs/hooks-reference.html#usememo)

<iframe width="560" height="315" src="https://www.youtube.com/embed/dHEf2Xm2_Qs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

# ===Перый сценарий использования useMemo.=== 
### Для повышения производительности и слишком сложным операцих (по типу пересчетов,сортировок и тд,постоянной работе с большими массивами)

![[useMemo.png]]


Возвращает ==мемоизированное== значение.

Принимает  «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

______________________________________________
## Разница useMemo и useEffect

У useMemo callback сработает при изменении параметров в массиве зависимостей, либо разово, если массив пустой.
Сработает когда? Когда дойдём строчкой до него.

У useEffect callback сработает при изменении параметров в массиве зависимостей, !НО сам вызов callback произойдёт как только вернётся jsx разметка, т.е. после return сработает

Также у useEffect больше режимов:
- Если массив пустой, то сработает 1 раз
- Если вообще параметров нет, то сработает при каждой перерисовке
- Если параметры есть, то от них и зависит
Все эти пункты сработают исключительно после того, как вернётся jsx, в то время, как useMemo выполнится последовательно, где он расположен

В целом useEffect - пасхалка к чистым функциям, что у них должны отсутствовать сайд-эффекты и если мы хотим всё же использовать сайд-эффект в функциональной компоненте, то используем useEffect

А useMemo используется просто для запоминания какого-то ресурсного участка кода (массив после фильтрации или долгие вычисления математические и т.д.)

P.S. А ещё в useEffect есть cleanup функция, а это уже совсем другая история


______________________________________________


# ===Второй сценарий использования useMemo.=== 
### Для того,чтобы React.memo работал корректно. Инными словами useMemo помагает .React.memo
Например мы передает в пропсах знаичения,которое будет менятся кажый раз,когда рендерится сраничка. 
В данном примере метод filter всегда будет возращять новый массив,и от этого будет дурить ReactMemo и он всегда будет перериросововать наш массив,даже если данные там не изменились. От этого весь смысл от ReactMemo теряется.

![[useMemo_2_1.png]]
Но мы можем этот новый массив обернуть в useMemo и уже он будет выполнять создания нового массива,если это нужно. (напимер изминения users с параметров useMemo)
Таким образом мы не будем вызывать filter каждый раз,после каждой операции,а только когда нам это нужно.

![[useMemo_2_2.png]]

Тут все более подробно 
<iframe width="560" height="315" src="https://www.youtube.com/embed/dHEf2Xm2_Qs?start=1820" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
